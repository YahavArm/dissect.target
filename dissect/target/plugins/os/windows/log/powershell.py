from __future__ import annotations

from typing import TYPE_CHECKING

from dissect.target.exceptions import UnsupportedPluginError
from dissect.target.helpers.record import TargetRecordDescriptor
from dissect.target.plugin import Plugin, export

if TYPE_CHECKING:
    from collections.abc import Iterator

    from dissect.target.helpers.record import DynamicDescriptor
    from dissect.target.target import Target

PowershellScriptblockRecord = TargetRecordDescriptor(
    "filesystem/windows/logs/powershell/scriptblock",
    [
        ("datetime", "ts"),
        ("string", "activity_id"),
        ("string", "scriptblock_id"),
        ("string", "scriptblock"),
        ("uint32[]", "event_record_ids"),
        ("uint32", "pid"),
        ("uint32","tid"),
        ("uint32", "total_messages"),
        ("string", "user_sid"),
        ("boolean", "script_complete"),
        ("path", "script_path")
    ],
)

class PowershellEvents(Plugin):
    """Plugin for parsing Powershell EVTX related events"""
    SCRIPTBLOCK_EVENTID = 4104
    LOGS_DIR_PATH = "sysvol/windows/system32/winevt/logs/"
    OPERATIONAL_LOG_PATH = "Microsoft-Windows-PowerShell%4Operational.evtx"

    def __init__(self, target: Target):
        super().__init__(target)
        self.log_path = self.target.fs.path(self.LOGS_DIR_PATH + self.OPERATIONAL_LOG_PATH)

    def check_compatible(self) -> None:
        if not self.log_path.exists():
            raise UnsupportedPluginError("Powershell Operational log was not found")


    def build_scriptblock(self, scriptblock_group: list[DynamicDescriptor]) -> PowershellScriptblockRecord:
            script_complete = True
            scriptblock_id = scriptblock_group[0].ScriptBlockId
            group_msg_total = int(scriptblock_group[0].MessageTotal)
            event_record_ids = [int(log.EventRecordID) for log in scriptblock_group]
            if len(scriptblock_group) < group_msg_total:
                self.target.log.warning("ScriptBlock with id %s is incomplete", scriptblock_id)
                script_complete = False

            full_script = "".join([log.ScriptBlockText for log in scriptblock_group])
            yield PowershellScriptblockRecord(
                ts=scriptblock_group[0].ts,
                activity_id=scriptblock_group[0].Correlation_ActivityID,
                scriptblock_id=scriptblock_id,
                scriptblock=full_script,
                event_record_ids=event_record_ids,
                pid=int(scriptblock_group[0].Execution_ProcessID),
                tid=int(scriptblock_group[0].Execution_ThreadID),
                total_messages = group_msg_total,
                user_sid=scriptblock_group[0].Security_UserID,
                script_complete=script_complete,
                script_path=scriptblock_group[0].Path
            )


    @export(record=PowershellScriptblockRecord)
    def scriptblocks(self) -> Iterator[PowershellScriptblockRecord]:
        """Parse PowerShell event log entries with ID 4104, which are generated by Script Block Logging.

        Script Block Logging is a PowerShell feature that logs the contents of all script blocks processed
        by the PowerShell engine, including commands, scripts, functions, and code blocks.
        These events are logged inWindows Event Log (Microsoft-Windows-PowerShell/Operational).
        """
        events = self.target.evtx(logs_dir = self.LOGS_DIR_PATH, log_file_glob=self.OPERATIONAL_LOG_PATH)

        """The executed Scriptblocks are broken to multiple events if the size of the block is too large.
        to get the entire script, the messages are grouped together and then combined to one record
        """
        scriptblock_group = []
        for event in events:
            if event.EventID == self.SCRIPTBLOCK_EVENTID:
                if event.MessageTotal == event.MessageNumber:
                    if not scriptblock_group:
                        scriptblock_group = [event]
                    yield from self.build_scriptblock(scriptblock_group)
                else:
                    scriptblock_group.append(event)
